/* autogenerated by Processing revision 1282 on 2022-05-30 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class nyan_cat_adventure extends PApplet {

PImage playerImg,nyan0,coinImg;
PImage[] tree=new PImage[4];
PImage[] car=new PImage[4];
PImage logImg; //replace this with coin image
int landX, landY;
float tranX=0, tranY=0;
Player player;
int playerState;
final int PLAYER_IDLE=0, PLAYER_UP=1, PLAYER_DOWN=2, PLAYER_RIGHT=3, PLAYER_LEFT=4;
final int CAT_PADX=30;
final int GAME_START = 0, GAME_RUN = 1, GAME_OVER = 2;
int gameState = 0;
int coinCount=0;
int hiScore=0;

boolean debugMode=false;
Map[] maps=new Map[40];
final int ROAD=1, GRASS=0;
final int TREE=1;
final int CAR=1;

 public void initGame() {
  for (int i=0; i<maps.length; i++) {
    if (i<16) {
      maps[i]=new Grass(20-i);
    } else {
      switch(floor(random(2))) {
      case 0:
        maps[i]=new Grass(20-i);
        break;
      case 1:
        maps[i]=new Road(20-i);
        break;
      }
    }
  }
}

 public void setup() {
  /* size commented out by preprocessor */;
  noStroke();
  nyan0 = loadImage("img/nyan0.png");
  playerImg=nyan0;
  logImg=loadImage("img/gutter-cover.png");
  coinImg=loadImage("img/coin.png");

  //loading Tree Image
  for (int i=0; i<4; i++) {
    tree[i] = loadImage("img/tree" + i + ".png") ;
    car[i] = loadImage("img/car" + i + ".png") ;
  }

  initGame();

  player = new Player();
}


 public void draw() {

  pushMatrix();
  //Adjust Rolling Speed
  switch (gameState) {

  case GAME_START:
    if (tranX<-400) {
      tranX=-400;
      tranY=800;
    }
    if (tranX<0) {
      for (int i=-400; i<=0; i=i+20) {
        if (tranX<=i) {
          tranX+=1;
          tranY-=2;
        }
      }
    }
    break;
  case GAME_RUN:
    for (int i=550; i>=0; i=i-25) {
      if (tranY+player.y<=i) {
        tranX-=0.125f;
        tranY+=0.25f;
      }
    }
    tranX-=0.125f;
    tranY+=0.25f;
    break;
  case GAME_OVER:
    playerImg = logImg;
  }


  //Rolling the screen
  translate(tranX, tranY);


  //draw map

  for (int j=39; j>=0; j--) {
    maps[j].display();
  }
  for (int j=39; j>0; j--) {
    roadMarkingLine(j);
  }

  //draw objects
  for (int j=39; j>=13; j--) {
    maps[j].displayObjects();
  }

  //drawPlayer
  player.update();

  //draw objects
  for (int j=12; j>=0; j--) {
    maps[j].displayObjects();
  }

  popMatrix();

  //draw score

  drawScore();
}

 public void keyPressed() {
  // Add your moving input code here
  if (key ==CODED) {
    switch(keyCode) {
    case UP:
      if (gameState==GAME_START && tranX>=0) {
        gameState=GAME_RUN;
      }
      if (gameState==GAME_RUN && playerState==PLAYER_IDLE && maps[13].checkObjects(player.offsetX)!=TREE) {
        playerState=PLAYER_UP;
        player.movingTimer=0;
        player.offsetY--;
        //offset map forward and create new map
        for (int i=0; i<39; i++) {
          maps[i]=maps[i+1];
        }
        switch(floor(random(3))) {
        case 0:
          maps[39]=new Grass(player.offsetY-27);
          break;
        case 1:
          maps[39]=new Road(player.offsetY-27);
          break;
        case 2:
          maps[39]=new Road(player.offsetY-27);
          break;
        }
      }

      
      break;
    case RIGHT:
      if (gameState==GAME_RUN && playerState==PLAYER_IDLE && player.offsetX<8 && maps[12].checkObjects(player.offsetX+1)!=TREE) {
        playerState=PLAYER_RIGHT;
        player.movingTimer=0;
        player.offsetX++;
      }
      break;
    case LEFT:
      if (gameState==GAME_RUN && playerState==PLAYER_IDLE && player.offsetX>0 && maps[12].checkObjects(player.offsetX-1)!=TREE) {
        playerState=PLAYER_LEFT;
        player.movingTimer=0;
        player.offsetX--;
      }
      break;
    case DOWN:
      if (gameState==GAME_RUN && playerState==PLAYER_IDLE && maps[11].checkObjects(player.offsetX)!=TREE) {
        playerState=PLAYER_DOWN;
        player.movingTimer=0;
        player.offsetY++;

        //offset map backward and create new map
        for (int i=39; i>0; i--) {
          maps[i]=maps[i-1];
        }
      }
      break;
    }
  } else {
    if (key=='b') {
      // Press B to toggle demo mode
      debugMode = !debugMode;
    }
    if (key==ENTER){
      if (gameState==GAME_OVER) {
        gameState=GAME_START;
        player.x=560;
        player.y=680;
        player.offsetX=4;
        player.offsetY=8;
        player.movingTimer=0;
        playerImg = loadImage("img/nyan0.png");
        initGame();
      }
    }
  }
}
class Car {
  float x, y;
  float carX, carY;
  float speed;
  PImage carImg;
  Car(int x, int y, float speed) {
    this.x=x;
    this.y=y;
    this.speed=speed;
    carX=(x+6)*80+y*(-30);
    carY=(x+6)*20+y*60;
    carImg=car[floor(random(4))];
  }

   public void display() {
    drawImage(carImg, carX, carY);
    if (debugMode) {
      fill(0);
      textSize(30);
      text(x+","+y, carX, carY);
    }
  }

   public void update() {
    carX += speed*4;
    carY += speed*1;
    x+=speed/20;
    if (speed>0 && x>14) {
      x=-7;
      carX=(x+6)*80+y*(-30);
      carY=(x+6)*20+y*60;
    } else if (x<-7) {
      x=15;
      carX=(x+6)*80+y*(-30);
      carY=(x+6)*20+y*60;
    }
  }

   public boolean checkCollision(Player player, int playerState) {
    if(playerState==PLAYER_UP||playerState==PLAYER_DOWN||playerState==PLAYER_IDLE){
      if(isHit(player.offsetX , player.offsetY,1,1,x,y,1,1)){
        return true;
      }
    }
    return false;
  }
}
class Coin {
  int x, y;
  int coinX, coinY;
  float floatTimer;
  boolean isAlive;

  Coin(int x, int y) {
    this.x=x;
    this.y=y;
    coinX=(x+6)*80+y*(-30);
    coinY=(x+6)*20+y*60;
    isAlive=true;
    floatTimer=0;
  }

   public void display() {
    if (isAlive) {
      drawImage(coinImg, coinX, coinY+5+sin(floatTimer)*10);
      floatTimer+=TWO_PI/25;
    }
  }

   public boolean checkCollision(Player player, int playerState) {
    if (playerState==PLAYER_UP||playerState==PLAYER_DOWN||playerState==PLAYER_IDLE) {
      if (isHit(player.offsetX, player.offsetY, 1, 1, x, y, 1, 1)) {
        return true;
      }
    }
    return false;
  }
}
//code for draw road marking line
 public void roadMarkingLine(int y) {
  if (maps[y].type==ROAD && maps[y-1].type==ROAD) {
    for (int i=0; i<19; i++) {
      landX=i*80+maps[y].y*(-30);
      landY=i*20+maps[y].y*60;

      fill(100);
      //draw line
      if (i%2==0) {
        quad(landX+1, landY-2, landX+81, landY+18, landX+79, landY+22, landX-1, landY+2);
      }
    }
  }
}

//code for draw image form the position point
 public void drawImage(PImage img, float x, float y) {
  if ((img.width-30)%80==0) {
    int n=PApplet.parseInt((img.width-30)/80);
    image(img, x, y-(img.height-20*n));
  }
}


//check collision
 public boolean isHit(float ax, float ay, float aw, float ah, float bx, float by, float bw, float bh) {
  return  ax + aw > bx &&    // a right edge past b left
    ax < bx + bw &&    // a left edge past b right
    ay + ah > by &&    // a top edge past b bottom
    ay < by + bh;
}

 public int score() {
  return 8-player.offsetY;
}

 public void drawScore() {
  textSize(100);
  fill(255);
  text(score(), 30, 100);
  textSize(30);
  fill(255,255,0);
  text(coinCount, 30, 200);
}
class Grass extends Map {
  Tree[] trees;
  Coin coin;
  Grass(int y) {
    super(y);
    type=GRASS;
    //generate tree
    trees=new Tree[floor(random(5))];
    int newTreeX;
    for (int i=0; i<trees.length; i++) {
      if (floor(random(2))==0) {
        newTreeX=floor(random(3));
        while (checkTreeXreuse(newTreeX, i)) {
          newTreeX=6+floor(random(3));
        }
      } else {
        newTreeX=6+floor(random(3));
        while (checkTreeXreuse(newTreeX, i)) {
          newTreeX=floor(random(3));
        }
      }
      trees[i]=new Tree(newTreeX, y);
    }

    //generate Coin
    if (y%5==0) {
      coin=new Coin(3+floor(random(3)), y);
    }
  }

   public void display() {
    for (int i=0; i<20; i++) {
      if (i<6 || i>14) {
        fill(0xFF0CB43C);
      } else {
        fill(0xFF0ED145);
      }
      landX=i*80+y*(-30);
      landY=i*20+y*60;

      quad(landX, landY-5, landX+80, landY+20-5, landX+110, landY-40-5, landX+30, landY-60-5);
      if (i<6 || i>14) {
        fill(0xFF0A9030);
      } else {
        fill(0xFF0CB43C);
      }
      quad(landX, landY, landX+80, landY+20, landX+80, landY+20-5, landX, landY-5);
      if (debugMode) {
        fill(255);
        textSize(30);
        text(y, landX, landY);
      }
    }
  }

   public void displayObjects() {
    for (int i=0; i<trees.length; i++) {
      trees[i].display();
    }
    if (y%5==0) {
      coin.display();
      if (coin.checkCollision(player, PLAYER_UP) && coin.isAlive) {
        coinCount++;
        coin.isAlive=false;
      }
    }
  }

   public int checkObjects(int x) {
    //check tree
    for (int i=0; i<trees.length; i++) {
      if (trees[i].x==x) {
        return TREE;
      }
    }
    return -1;
  }

   public boolean checkTreeXreuse(int newTreeX, int n) {
    for (int i=0; i<n; i++) {
      if (trees[i].x==newTreeX) {
        return true;
      }
    }
    return false;
  }
}
class Item {
  int x, y;
  int coinX, coinY;
  PImage logImg; //for permenent
  Item(int x, int y) {
    this.x=x;
    this.y=y;
    coinX=(x+6)*80+y*(-30);
    coinY=(x+6)*20+y*60;
  }

   public void display() {
    if ( maps[11].checkObjects(player.offsetX)!=TREE && maps[11].checkObjects(player.offsetX)!=CAR) {
      drawImage(logImg, coinX, coinY); //change the log here
    }
  }
}
class Map{
  int y;
  int type;
   public void display(){}
   public void displayObjects(){}
  
   public int checkObjects(int x){
    return -1;
  }
  Map(int y){
    this.y=y;
  }
  
}


  
class Player {
  float x, y;
  int offsetX, offsetY;
  int movingTimer;

  Player() {
    x=560;
    y=680;
    offsetX=4;
    offsetY=8;
    movingTimer=0;
  }

   public void update() {

    switch(playerState) {
    case PLAYER_IDLE:
      if (maps[12].type==GRASS) {
        drawImage(playerImg, x, y-5);
      } else {
        drawImage(playerImg, x, y);
      }
      break;
    case PLAYER_UP:
      movingTimer+=1;
      x+=3;
      y-=6;
      drawImage(playerImg, x, y-10);
      break;
    case PLAYER_DOWN:
      movingTimer+=1;
      x-=3;
      y+=6;
      drawImage(playerImg, x, y-10);
      break;
    case PLAYER_LEFT:
      movingTimer+=1;
      x-=8;
      y-=2;
      drawImage(playerImg, x, y-10);
      break;
    case PLAYER_RIGHT:
      movingTimer+=1;
      x+=8;
      y+=2;
      drawImage(playerImg, x, y-10);
      break;
    }

    if (debugMode) {
      fill(0);
      textSize(30);
      text(offsetX+","+offsetY, x+55, y);
    }

    if (movingTimer==10) {
      playerState=PLAYER_IDLE;
      movingTimer=0;
    }
  }
}
class Road extends Map {
  Car[] cars;
  Road(int y) {
    super(y);
    type=ROAD;

    //generate car
    cars=new Car[3];
    int space=floor(random(4,12));
    float speed;
    if(floor(random(2))==0){
      speed=random(0.2f,1);
    }else{
      speed=-random(0.2f,1);
    }
    int newCarX=floor(random(-6,-3));
    cars[0]=new Car(newCarX,y,speed);
    cars[1]=new Car(newCarX+space,y,speed);
    cars[2]=new Car(newCarX+15,y,speed);
  }

   public void display() {
    for (int i=0; i<20; i++) {
      fill(0xFF404040);
      landX=i*80+y*(-30);
      landY=i*20+y*60;
      quad(landX, landY, landX+80, landY+20, landX+110, landY-40, landX+30, landY-60);

      //draw line
      if (i%2==0) {
        quad(landX-14, landY+28, landX+66, landY+48, landX+64, landY+52, landX-14, landY+32);
      }

      if (debugMode) {
        fill(255);
        textSize(30);
        text(y, landX, landY);
      }
    }
  }

   public void displayObjects() {
    for (int i=cars.length-1; i>=0; i--) {
      cars[i].display();
      cars[i].update();
      if(cars[i].checkCollision(player,PLAYER_UP)){
        gameState=GAME_OVER;
      }
    }
  }

   public int checkObjects(int x) {
    //check car
    for (int i=0; i<cars.length; i++) {
      if (cars[i].x==x) {
        return CAR;
      }
    }
    return -1;
  }

  
}
class Tree {
  int x, y;
  int treeX, treeY;
  PImage treeImg;
  Tree(int x, int y) {
    this.x=x;
    this.y=y;
    treeX=(x+6)*80+y*(-30);
    treeY=(x+6)*20+y*60;
    treeImg=tree[floor(random(4))];
  }



   public void display() {
    drawImage(treeImg, treeX, treeY);
  }
}
/*
//generate coin
coins=new Coin[floor(random(5))];
int newCoinX;
for (int i=0; i<coins.length; i++) {
  if (floor(random(2))==0) {
    newCoinX=floor(random(3));
    while (checkCoinXreuse(newCoinX, i)) {
      newCoinX=6+floor(random(3));
    }
  } else {
    newCoinX=6+floor(random(3));
    while (checkCoinXreuse(newCoinX, i)) {
      newCoinX=floor(random(3));
    }
  }
  coins[i]=new Coin(newCoinX, y);
}
*/


  public void settings() { size(1280, 720, P2D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "nyan_cat_adventure" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
