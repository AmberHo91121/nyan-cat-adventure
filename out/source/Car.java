/* autogenerated by Processing revision 1282 on 2022-05-30 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Car extends PApplet {

class Car {
  float x, y;
  float carX, carY;
  float speed;
  PImage carImg;
  Car(int x, int y, float speed) {
    this.x=x;
    this.y=y;
    this.speed=speed;
    carX=(x+6)*80+y*(-30);
    carY=(x+6)*20+y*60;
    carImg=car[floor(random(4))];
  }

   public void display() {
    drawImage(carImg, carX, carY);
    if (debugMode) {
      fill(0);
      textSize(30);
      text(x+","+y, carX, carY);
    }
  }

   public void update() {
    carX += speed*4;
    carY += speed*1;
    x+=speed/20;
    if (speed>0 && x>14) {
      x=-7;
      carX=(x+6)*80+y*(-30);
      carY=(x+6)*20+y*60;
    } else if (x<-7) {
      x=15;
      carX=(x+6)*80+y*(-30);
      carY=(x+6)*20+y*60;
    }
  }

   public boolean checkCollision(Player player, int playerState) {
    if(playerState==PLAYER_UP||playerState==PLAYER_DOWN||playerState==PLAYER_IDLE){
      if(isHit(player.offsetX , player.offsetY,1,1,x,y,1,1)){
        return true;
      }
    }
    return false;
  }
}
class Coin {
  int x, y;
  int coinX, coinY;
  float floatTimer;
  boolean isAlive;

  Coin(int x, int y) {
    this.x=x;
    this.y=y;
    coinX=(x+6)*80+y*(-30);
    coinY=(x+6)*20+y*60;
    isAlive=true;
    floatTimer=0;
  }

   public void display() {
    if (isAlive) {
      drawImage(coinImg, coinX, coinY+5+sin(floatTimer)*10);
      floatTimer+=TWO_PI/25;
    }
  }

   public boolean checkCollision(Player player, int playerState) {
    if (playerState==PLAYER_UP||playerState==PLAYER_DOWN||playerState==PLAYER_IDLE) {
      if (isHit(player.offsetX, player.offsetY, 1, 1, x, y, 1, 1)) {
        return true;
      }
    }
    return false;
  }
}
//code for draw road marking line
 public void roadMarkingLine(int y) {
  if (maps[y].type==ROAD && maps[y-1].type==ROAD) {
    for (int i=0; i<19; i++) {
      landX=i*80+maps[y].y*(-30);
      landY=i*20+maps[y].y*60;

      fill(100);
      //draw line
      if (i%2==0) {
        quad(landX+1, landY-2, landX+81, landY+18, landX+79, landY+22, landX-1, landY+2);
      }
    }
  }
}

//code for draw image form the position point
 public void drawImage(PImage img, float x, float y) {
  if ((img.width-30)%80==0) {
    int n=PApplet.parseInt((img.width-30)/80);
    image(img, x, y-(img.height-20*n));
  }
}


//check collision
 public boolean isHit(float ax, float ay, float aw, float ah, float bx, float by, float bw, float bh) {
  return  ax + aw > bx &&    // a right edge past b left
    ax < bx + bw &&    // a left edge past b right
    ay + ah > by &&    // a top edge past b bottom
    ay < by + bh;
}

 public int score() {
  return 8-player.offsetY;
}

 public void drawScore() {
  textSize(100);
  fill(255);
  text(score(), 30, 100);
  textSize(30);
  fill(255,255,0);
  text(coinCount, 30, 200);
}
class Grass extends Map {
  Tree[] trees;
  Coin coin;
  Grass(int y) {
    super(y);
    type=GRASS;
    //generate tree
    trees=new Tree[floor(random(5))];
    int newTreeX;
    for (int i=0; i<trees.length; i++) {
      if (floor(random(2))==0) {
        newTreeX=floor(random(3));
        while (checkTreeXreuse(newTreeX, i)) {
          newTreeX=6+floor(random(3));
        }
      } else {
        newTreeX=6+floor(random(3));
        while (checkTreeXreuse(newTreeX, i)) {
          newTreeX=floor(random(3));
        }
      }
      trees[i]=new Tree(newTreeX, y);
    }

    //generate Coin
    if (y%5==0) {
      coin=new Coin(3+floor(random(3)), y);
    }
  }

   public void display() {
    for (int i=0; i<20; i++) {
      if (i<6 || i>14) {
        fill(0xFF0CB43C);
      } else {
        fill(0xFF0ED145);
      }
      landX=i*80+y*(-30);
      landY=i*20+y*60;

      quad(landX, landY-5, landX+80, landY+20-5, landX+110, landY-40-5, landX+30, landY-60-5);
      if (i<6 || i>14) {
        fill(0xFF0A9030);
      } else {
        fill(0xFF0CB43C);
      }
      quad(landX, landY, landX+80, landY+20, landX+80, landY+20-5, landX, landY-5);
      if (debugMode) {
        fill(255);
        textSize(30);
        text(y, landX, landY);
      }
    }
  }

   public void displayObjects() {
    for (int i=0; i<trees.length; i++) {
      trees[i].display();
    }
    if (y%5==0) {
      coin.display();
      if (coin.checkCollision(player, PLAYER_UP) && coin.isAlive) {
        coinCount++;
        coin.isAlive=false;
      }
    }
  }

   public int checkObjects(int x) {
    //check tree
    for (int i=0; i<trees.length; i++) {
      if (trees[i].x==x) {
        return TREE;
      }
    }
    return -1;
  }

   public boolean checkTreeXreuse(int newTreeX, int n) {
    for (int i=0; i<n; i++) {
      if (trees[i].x==newTreeX) {
        return true;
      }
    }
    return false;
  }
}
class Item {
  int x, y;
  int coinX, coinY;
  PImage logImg; //for permenent
  Item(int x, int y) {
    this.x=x;
    this.y=y;
    coinX=(x+6)*80+y*(-30);
    coinY=(x+6)*20+y*60;
  }

   public void display() {
    if ( maps[11].checkObjects(player.offsetX)!=TREE && maps[11].checkObjects(player.offsetX)!=CAR) {
      drawImage(logImg, coinX, coinY); //change the log here
    }
  }
}
class Map{
  int y;
  int type;
   public void display(){}
   public void displayObjects(){}
  
   public int checkObjects(int x){
    return -1;
  }
  Map(int y){
    this.y=y;
  }
  
}


  
class Player {
  float x, y;
  int offsetX, offsetY;
  int movingTimer;

  Player() {
    x=560;
    y=680;
    offsetX=4;
    offsetY=8;
    movingTimer=0;
  }

   public void update() {

    switch(playerState) {
    case PLAYER_IDLE:
      if (maps[12].type==GRASS) {
        drawImage(playerImg, x, y-5);
      } else {
        drawImage(playerImg, x, y);
      }
      break;
    case PLAYER_UP:
      movingTimer+=1;
      x+=3;
      y-=6;
      drawImage(playerImg, x, y-10);
      break;
    case PLAYER_DOWN:
      movingTimer+=1;
      x-=3;
      y+=6;
      drawImage(playerImg, x, y-10);
      break;
    case PLAYER_LEFT:
      movingTimer+=1;
      x-=8;
      y-=2;
      drawImage(playerImg, x, y-10);
      break;
    case PLAYER_RIGHT:
      movingTimer+=1;
      x+=8;
      y+=2;
      drawImage(playerImg, x, y-10);
      break;
    }

    if (debugMode) {
      fill(0);
      textSize(30);
      text(offsetX+","+offsetY, x+55, y);
    }

    if (movingTimer==10) {
      playerState=PLAYER_IDLE;
      movingTimer=0;
    }
  }
}
class Road extends Map {
  Car[] cars;
  Road(int y) {
    super(y);
    type=ROAD;

    //generate car
    cars=new Car[3];
    int space=floor(random(4,12));
    float speed;
    if(floor(random(2))==0){
      speed=random(0.2f,1);
    }else{
      speed=-random(0.2f,1);
    }
    int newCarX=floor(random(-6,-3));
    cars[0]=new Car(newCarX,y,speed);
    cars[1]=new Car(newCarX+space,y,speed);
    cars[2]=new Car(newCarX+15,y,speed);
  }

   public void display() {
    for (int i=0; i<20; i++) {
      fill(0xFF404040);
      landX=i*80+y*(-30);
      landY=i*20+y*60;
      quad(landX, landY, landX+80, landY+20, landX+110, landY-40, landX+30, landY-60);

      //draw line
      if (i%2==0) {
        quad(landX-14, landY+28, landX+66, landY+48, landX+64, landY+52, landX-14, landY+32);
      }

      if (debugMode) {
        fill(255);
        textSize(30);
        text(y, landX, landY);
      }
    }
  }

   public void displayObjects() {
    for (int i=cars.length-1; i>=0; i--) {
      cars[i].display();
      cars[i].update();
      if(cars[i].checkCollision(player,PLAYER_UP)){
        gameState=GAME_OVER;
      }
    }
  }

   public int checkObjects(int x) {
    //check car
    for (int i=0; i<cars.length; i++) {
      if (cars[i].x==x) {
        return CAR;
      }
    }
    return -1;
  }

  
}
class Tree {
  int x, y;
  int treeX, treeY;
  PImage treeImg;
  Tree(int x, int y) {
    this.x=x;
    this.y=y;
    treeX=(x+6)*80+y*(-30);
    treeY=(x+6)*20+y*60;
    treeImg=tree[floor(random(4))];
  }



   public void display() {
    drawImage(treeImg, treeX, treeY);
  }
}
/*
//generate coin
coins=new Coin[floor(random(5))];
int newCoinX;
for (int i=0; i<coins.length; i++) {
  if (floor(random(2))==0) {
    newCoinX=floor(random(3));
    while (checkCoinXreuse(newCoinX, i)) {
      newCoinX=6+floor(random(3));
    }
  } else {
    newCoinX=6+floor(random(3));
    while (checkCoinXreuse(newCoinX, i)) {
      newCoinX=floor(random(3));
    }
  }
  coins[i]=new Coin(newCoinX, y);
}
*/


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Car" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
